---
layout: default
title: 02_JWT
parent: 01_Authorization
grand_parent: Web
nav_order: 2
has_children: false
---

# JWT (JSON Web Token)  

## 1. 토큰 기반 인증  

### 1) 토큰 기반 인증 과정  

  (1) 토큰 기반 인증 시스템에서는 클라이언트가 서버에 접속을 하면 <u>서버에서 해당 클라이언트에게 인증되었다는 의미로 '토큰'을 부여</u>함.  
  (2) 토큰을 발급받은 클라이언트는 서버에 요청을 보낼 때 <u>요청 헤더에 토큰을 심어서 보냄</u>.  
  (3) 서버에서는 클라이언트로부터 받은 토큰을 <u>서버에서 제공한 토큰과 일치하는지 여부를 체크</u>하여 인증 과정을 처리.  


### 2) 토큰 기반 인증을 사용하는 이유 (장점)  

**1. 무상태성(Stateless) & 확장성(Scalability)**  

> **Stateful**  
> - Stateful한 서버는 클라이언트에서 요청을 받을 때마다 클라이언트의 상태를 계속 유지.  
> - <u>서버</u>의 메모리 또는 DB<u>에 상태 저장</u>  
> - 서버(세션) 기반 인증 시스템  
>
> **Stateless**  
> - 클라이언트에서 들어오는 요청만으로 작업을 처리.  
> - <u>서버에 상태 저장X</u> (서버에서 사용자 인증정보 관리X)  
> - 토큰 기반 인증 시스템  

- 토큰은 클라이언트 측에 저장되기 때문에 서버는 완전히 Stateless하며, 클라이언트와 서버의 연결고리가 없기 때문에 확장하기에 매우 적합.  
- 서버를 확장하여 분산 처리를 하는 경우, 사용자 정보를 세션에 저장하면 사용자는 처음 로그인 했던 서버로만 요청을 하도록 설정해야 하지만, 토큰을 사용시에는 어떤 서버로 요청보내도 상관 없음.  

**2. 확장성(Extensibility)**  
- 시스템의 확장성을 의미하는 Scalability와 달리 Extensibility는 <u>로그인 정보가 사용되는 분야의 확장</u>을 의미.  
- 토큰 기반의 인증 시스템에서는 토큰에 <u>선택적인 권한만 부여</u>하여 발급할 수 있으며,  
OAuth의 경우 Facebook, Google 등 <u>소셜 계정으로 다른 웹서비스에서도 로그인</u> 가능.  

**3. 여러 플랫폼 및 도메인**  
- 웹 어플리케이션에서 세션을 관리할 때 자주 사용되는 쿠키는 단일 도메인 및 서브 도메인에서만 작동하도록 설계되어 있음. 따라서 쿠키를 여러 도메인에서 관리하는 것은 번거로움.
- 모바일 어플리케이션에서는 쿠키 사용 불가.  
- <u>토큰을 사용하면 CORS(Cross-Origin Resource Sharing)를 해결</u>할 수 있어 인증정보를 다른 어플리케이션으로 전달 가능.  

**4. 보안**  
- 클라이언트가 서버로 요청을 보낼 때 더 이상 쿠키를 전달하지 않으므로, 쿠키 사용에 의한 취약점이 사라지게 됨.  
- 하지만 토큰 환경의 취약점이 존재할 수 있으므로 이에 대한 대비는 필요.  


### 3) 토큰 기반 인증 방식의 단점  

(1) 쿠키/세션과 다르게 토큰 자체의 데이터 길이가 길어, 인증 요청이 많아질수록 네트워크 부하가 심해질수 있다.  
(2) Payload 자체는 암호화되지 않기 때문에 유저의 중요한 정보는 담을 수 없다.  
(3) 토큰을 탈취당하면 대처하기 어렵다. (따라서 사용 기간 제한을 설정하는 식으로 극복)  

<hr/>

## 2. JWT(JSON Web Token)란?  
- 웹에서 사용되는 <u>JSON 형식의 토큰에 대한 표준 규격</u>  
- 사용자의 인증(authentication) 또는 인가(authorization) 정보를 서버와 클라이언트 간에 안전하게 주고 받기 위해서 사용
- Claim 기반(다른 토큰과 비교)


### 1) JWT의 구조

하나의 JWT 토큰은 헤더(header), 페이로드(payload), 서명(signature) 세 부분으로 이루어지며 각 부분은 '.' 기호로 구분됨.
JWT는 JSON 데이터를 Base64 URL-safe Encode함.

```
<헤더>.<페이로드>.<서명>
```


  **(1) 헤더(header)**  
  <u>서명 암호화 알고리즘(해시 암호화 알고리즘)</u>과 <u>토큰의 유형</u>으로 구성  
  
  ```js
  {
    "alg": "HS256",   // 서명 암호화 알고기즘 (eg. HMAC SHA256. RSA)
    "typ": "JWT"      // 토큰의 유형
  }
  ```
  
  
  **(2) 페이로드(payload)**  
  <u>claim</u>이라고도 불리는 사용자의 인증/인가 정보. <u>시스템에서 실제로 사용될 정에 대한 내용</u>  
  정해진 형식은 없지만, 대표적으로 Registered claims, Public claims, Private claims 이렇게 세 가지로 나뉨  
  - Registed claims : 미리 정의된 클레임.
    - iss(issuer; 발행자)
    - exp(expireation time; 만료 시간)
    - sub(subject; 제목)
    - iat(issued At; 발행 시간)
    - jti(JWI ID)
  - Public claims : 사용자가 정의할 수 있는 클레임. 공개용 정보 전달을 위해 사용.
  - Private claims : 해당하는 당사자들 간에 정보를 공유하기 위해 만들어진 사용자 지정 클레임. 외부에 공개되도 상관없지만 해당 유저를 특정할 수 있는 정보들을 담음.
  
  **(3) 서명(signature)**  
  시그니처의 구조는(헤더 + 페이로드)와 서버가 갖고 있는 유일한 key 값을 합친 것을 헤더에서 정의한 알고리즘으로 암호화 한 <u>비밀키(secret key)</u>로 저장  
